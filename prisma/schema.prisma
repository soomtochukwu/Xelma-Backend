generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User role enum
enum UserRole {
  USER
  ADMIN
  ORACLE
}

// User model for wallet-based authentication
model User {
  id              String            @id @default(uuid())
  walletAddress   String            @unique
  publicKey       String
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  lastLoginAt     DateTime?
  
  // Game stats
  wins            Int               @default(0)
  streak          Int               @default(0)
  virtualBalance  Float             @default(1000)

  // Role
  role            UserRole          @default(USER)

  // Relations
  authChallenges  AuthChallenge[]
  messages        Message[]
  predictions     Prediction[]
  predictions     Prediction[]
  stats           UserStats?

  @@index([walletAddress])
}

// Auth challenge model for replay protection
model AuthChallenge {
  id            String    @id @default(uuid())
  userId        String?
  user          User?     @relation(fields: [userId], references: [id], onDelete: Cascade)
  challenge     String    @unique
  walletAddress String
  createdAt     DateTime  @default(now())
  expiresAt     DateTime
  usedAt        DateTime?
  isUsed        Boolean   @default(false)

  @@index([challenge])
  @@index([walletAddress])
  @@index([expiresAt])
}

// Prediction model for user price predictions
model Prediction {
  id          String   @id @default(uuid())
  userId      String
  roundId     String
  mode        Int      // 0 = Up/Down, 1 = Legends (exact price)
  choice      String?  // "up" or "down" for mode 0; null for mode 1
  guessPrice  Decimal? @db.Decimal(10, 4)  // only for mode 1 (e.g. 0.2297)
  amount      Decimal  @db.Decimal(18, 8)   // virtual XLM staked
  createdAt   DateTime @default(now())

  user        User     @relation(fields: [userId], references: [id])
  round       Round    @relation(fields: [roundId], references: [id])

  @@index([userId])
  @@index([roundId])
}

// Round model for prediction rounds
model Round {
  id          String   @id @default(uuid())
  mode        Int      // 0 = Up/Down, 1 = Legends
  startPrice  Decimal? @db.Decimal(10, 4)
  endPrice    Decimal? @db.Decimal(10, 4)
  startTime   DateTime
  endTime     DateTime
  status      String   // "open", "running", "closed"
  createdAt   DateTime @default(now())

  predictions Prediction[]

  @@index([status])
}

// UserStats model for leaderboard tracking
model UserStats {
  id                String   @id @default(uuid())
  userId            String   @unique
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Overall stats
  totalPredictions  Int      @default(0)
  correctPredictions Int     @default(0)
  totalEarnings     Decimal  @default(0) @db.Decimal(18, 8)
  
  // Mode-specific stats
  upDownWins        Int      @default(0)
  upDownLosses      Int      @default(0)
  upDownEarnings    Decimal  @default(0) @db.Decimal(18, 8)
  
  legendsWins       Int      @default(0)
  legendsLosses     Int      @default(0)
  legendsEarnings   Decimal  @default(0) @db.Decimal(18, 8)
  
  // Metadata
  updatedAt         DateTime @updatedAt
  
  @@index([totalEarnings])
}

// Game mode enum
enum GameMode {
  UP_DOWN    // Mode 0: Binary Up/Down predictions
  LEGENDS    // Mode 1: Price range predictions
}

// Round status enum
enum RoundStatus {
  PENDING    // Created but not started
  ACTIVE     // Accepting predictions
  LOCKED     // No more predictions, awaiting resolution
  RESOLVED   // Completed with results
  CANCELLED  // Admin cancelled
}

// Prediction side for Up/Down mode
enum PredictionSide {
  UP
  DOWN
}

// Round model for prediction rounds
model Round {
  id              String       @id @default(uuid())
  mode            GameMode
  status          RoundStatus  @default(PENDING)
  
  // Timing
  startTime       DateTime
  endTime         DateTime
  resolvedAt      DateTime?
  
  // Pricing
  startPrice      Float
  endPrice        Float?
  
  // Soroban (Mode 0 only)
  sorobanRoundId  String?      @unique
  
  // Pools
  poolUp          Float        @default(0)
  poolDown        Float        @default(0)
  
  // Legends mode: price ranges stored as JSON
  // Format: [{min: 0.20, max: 0.25, pool: 0}, ...]
  priceRanges     Json?
  
  // Relations
  predictions     Prediction[]
  
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt
  
  @@index([status])
  @@index([mode])
  @@index([startTime])
}

// Prediction model for user bets
model Prediction {
  id              String         @id @default(uuid())
  roundId         String
  round           Round          @relation(fields: [roundId], references: [id], onDelete: Cascade)
  
  userId          String
  user            User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Prediction details
  amount          Float
  side            PredictionSide? // For Up/Down mode
  priceRange      Json?           // For Legends: {min: 0.20, max: 0.25}
  
  // Results
  won             Boolean?
  payout          Float?
  
  createdAt       DateTime       @default(now())
  
  @@unique([roundId, userId])
  @@index([userId])
  @@index([roundId])
}
